samplesStats("sigma")
samplesStats("lambda")
samplesStats("P")
hist(s1, breaks=length(s1)/40, prob=T, xlim=c(0,1))
hist(s2, breaks=length(s2)/40, prob=T, add=T)
xs <- seq(0,1,len=101)
lines(xs,dnorm(xs,samplesStats("lambda")$mean[1],samplesStats("sigma")$mean[1]))
samplesStats("lambda")
lines(xs,dnorm(xs,samplesStats("lambda")$mean[1],1/sqrt(exp(3.3/2)^2)))
lines(xs,dnorm(xs,samplesStats("lambda")$mean[2],1/sqrt(exp(1.1/2)^2)))
modelString = "
# BUGS model specification begins ...
model {
for( i in 1 : N ) {
y[i]  ~ dnorm(mu[i], tau[i])
mu[i]  <- lambda[G[i]]
tau[i] <- lambdaTau[G[i]]
G[i]  ~ dcat(P[])
}
P[1:2] ~ ddirch(alpha[])  # dirichlet distribution
alpha[1] <- 1
alpha[2] <- 1
theta ~ dnorm(0.0, 1.0E-6)I(0.0, )
lambda[1] ~ dnorm(0.0, 1.0E-6)
lambda[2] <- lambda[1] + theta
#   log(lambdaTau[1]) <- (a+b)/2
#   log(lambdaTau[2]) <- (a-b)/2
#   a <- 2.2
#   b <- 1.1
lambdaTau[1] ~ dgamma(0.01,0.01)
lambdaTau[2] ~ dgamma(0.01,0.01)
sigma[1] <- 1 / sqrt(lambdaTau[1])
sigma[2] <- 1 / sqrt(lambdaTau[2])
}
# ... BUGS model specification ends.
" # close quote to end modelString
data.list = list(
y = samples,
N = length(samples),
G = rep(NA,nsamples)
)
run.model(modelString, samples=c("sigma", "lambda", "P"), data=data.list, chainLength=3e4)
data.list = list(
y = samples,
N = length(samples),
G = c(1, rep(NA,nsamples-2), 2)
)
run.model(modelString, samples=c("sigma", "lambda", "P"), data=data.list, chainLength=3e4)
samplesStats("sigma")
samplesStats("lambda")
samplesStats("P")
hist(s1, breaks=length(s1)/40, prob=T, xlim=c(0,1))
hist(s2, breaks=length(s2)/40, prob=T, add=T)
xs <- seq(0,1,len=101)
lines(xs,dnorm(xs,samplesStats("lambda")$mean[1],samplesStats("sigma")$mean[1]))
lines(xs,dnorm(xs,samplesStats("lambda")$mean[2],samplesStats("sigma")$mean[2]))
modelString = "
# BUGS model specification begins ...
model {
for( i in 1 : N ) {
y[i]  ~ dnorm(mu[i], tau[i])
mu[i]  <- lambda[G[i]]
tau[i] <- lambdaTau[G[i]]
G[i]  ~ dcat(P[])
}
P[1:2] ~ ddirch(alpha[])  # dirichlet distribution
alpha[1] <- 0.5
alpha[2] <- 0.5
theta ~ dnorm(0.0, 1.0E-6)I(0.0, )
lambda[1] ~ dnorm(0.0, 1.0E-6)
lambda[2] <- lambda[1] + theta
#   log(lambdaTau[1]) <- (a+b)/2
#   log(lambdaTau[2]) <- (a-b)/2
#   a <- 2.2
#   b <- 1.1
lambdaTau[1] ~ dgamma(0.01,0.01)
lambdaTau[2] ~ dgamma(0.01,0.01)
sigma[1] <- 1 / sqrt(lambdaTau[1])
sigma[2] <- 1 / sqrt(lambdaTau[2])
}
# ... BUGS model specification ends.
" # close quote to end modelString
data.list = list(
y = samples,
N = length(samples),
G = c(1, rep(NA,nsamples-2), 2)
)
run.model(modelString, samples=c("sigma", "lambda", "P"), data=data.list, chainLength=3e4)
samplesStats("sigma")
samplesStats("lambda")
samplesStats("P")
install.packages("googleVis")
library(googleVis)
url <- "http://members.unine.ch/martin.hilpert/mot.zip"
fn <- paste0(tempfile(), ".zip")
download.file(url, destfile = fn)
dat <- read.table(unzip(fn, files="mot/convdata.txt",
exdir=tempdir()),
header=TRUE)
library(googleVis)
plot(gvisMotionChart(dat, idvar="VERB", timevar="DECADE",
xvar="verbs", yvar="nouns",
sizevar="freq", colorvar="skewedness",
options=list(width=500, height=450),
chartid="Hilpert"))
house(dat)
head(dat)
numboxes <- 60
N <- rep(0, times = numboxes)
N[30:31] <- 1
N
D <- 0.3    # diffusion rate m^2/day
r <- 0.01   # net growth rate day^-1
delx <- 1   # m thickness of boxes
numboxes <- 60
Distance <- seq(from = 0.5, by = delx, length.out = numboxes)
Distance
library(deSolve)
parameters = list(D=D, r=r, delx=delx, numboxes=numboxes)
Aphid <- function(t, state, parameters) {
with(as.list(c(state, parameters)),{
deltax  <- c (0.5, rep(1, numboxes - 1), 0.5)
Flux    <- -D * diff(c(0, APHIDS, 0)) / deltax
dN <- -diff(Flux) / delx + N * r
list(dN)
})
}
N <- rep(0, times = numboxes)
N[30:31] <- 1
state <- c(N = N) # initialise state variables
times <-seq(0, 200, by = 1)
out <- ode.1D(state, times, Aphid, parms = 0, nspec = 1, names = "Aphid")
Aphid <- function(t, state, parameters) {
with(as.list(c(state, parameters)),{
deltax  <- c (0.5, rep(1, numboxes - 1), 0.5)
Flux    <- -D * diff(c(0, N, 0)) / deltax
dN <- -diff(Flux) / delx + N * r
list(dN)
})
}
out <- ode.1D(state, times, Aphid, parms = 0, nspec = 1, names = "Aphid")
head(out[,1:5])
state
out <- ode.1D(state, times, Aphid, parms = parameters, nspec = 1, names = "Aphid")
head(out[,1:5])
summary(out)
image(out, method = "filled.contour", grid = Distance,
xlab = "time, days", ylab = "Distance on plant, m",
main = "Aphid density on a row of plants")
parameters = list(D=0.3,     # diffusion rate; m^2/day
r=0.01,    # net growth rate; day^-1
delx=delx, # thickness of boxes; m
numboxes=60)
parameters
Aphid <- function(t, state, parameters) {
with(as.list(c(state, parameters)),{
deltax  <- c (0.5, rep(1, numboxes - 1), 0.5)
Flux    <- -D * diff(c(0, N, 0)) / deltax
dN <- -diff(Flux) / delx + N * r
list(dN)
})
}
as.list(c(state, parameters))
Aphid <- function(t, state, parameters) {
with(parameters),{
deltax  <- c (0.5, rep(1, numboxes - 1), 0.5)
Flux    <- -D * diff(c(0, state$N, 0)) / deltax
dN <- -diff(Flux) / delx + state$N * r
list(dN)
})
}
Aphid <- function(t, state, parameters) {
with(parameters,{
deltax  <- c (0.5, rep(1, numboxes - 1), 0.5)
Flux    <- -D * diff(c(0, state$N, 0)) / deltax
dN <- -diff(Flux) / delx + state$N * r
list(dN)
})
}
N <- rep(0, times = numboxes)
N[30:31] <- 1
state <- c(N = N) # initialise state variables
# let's run for 200 days
times <-seq(0, 200, by = 1)
out <- ode.1D(state, times, Aphid, parms = parameters, nspec = 1, names = "Aphid")
state
rep(0, times = numboxes)
state <- c(aphids = N) # initialise state variables
state
state <- c(aphids = as.vector(N)) # initialise state variables
state
state <- list(aphids = as.vector(N)) # initialise state variables
state
state <- list(aphids = N) # initialise state variables
state
state <- list(N = N) # initialise state variables
state
Aphid <- function(t, state, parameters) {
with(as.list(c(state, parameters)),{
deltax  <- c (0.5, rep(1, numboxes - 1), 0.5)
Flux    <- -D * diff(c(0, N, 0)) / deltax
dN <- -diff(Flux) / delx + N * r
list(dN)
})
}
as.list(c(state, parameters))
N <- rep(0, times = numboxes)
N[30:31] <- 1
state <- list(N = N) # initialise state variables
times <-seq(0, 200, by = 1)
out <- ode.1D(state, times, Aphid, parms = parameters, nspec = 1, names = "Aphid")
out <- ode.1D(as.vector(state), times, Aphid, parms = parameters, nspec = 1, names = "Aphid")
as.vector(state)
out <- ode.1D(state$N, times, Aphid, parms = parameters, nspec = 1, names = "Aphid")
head(out[,1:5])
summary(out)
state <- c(N = N) # initialise state variables
state
Aphid <- function(t, N, parameters) {
with(parameters,{
deltax  <- c (0.5, rep(1, numboxes - 1), 0.5)
Flux    <- -D * diff(c(0, N, 0)) / deltax
dN <- -diff(Flux) / delx + N * r
list(dN)
})
}
N <- rep(0, times = numboxes)
N[30:31] <- 1
state <- c(N = N) # initialise state variables
out <- ode.1D(state, times, Aphid, parms = parameters, nspec = 1, names = "Aphid")
head(out[,1:5])
summary(out)
image(out, method = "filled.contour", grid = seq(from = 0.5, by = delx, length.out = numboxes),
xlab = "time, days", ylab = "Distance on plant, m",
main = "Aphid density on a row of plants")
times <- seq(0, 300, by = 1)
out <- ode.1D(state, times, Aphid, parms = parameters, nspec = 1, names = "Aphid")
image(out, method = "filled.contour", grid = seq(from = 0.5, by = delx, length.out = numboxes),
xlab = "time, days", ylab = "Distance on plant, meters",
main = "Aphid density on a row of plants")
c(0, N, 0)
diff(c(0, N, 0))
c (0.5, rep(1, numboxes - 1), 0.5)
f <- function(t, y, dy, parameters) {
res1 <- dy[1] + y[1] - y[2]
res2 <- y[2] * y[1] - t
list(c(res1, res2))
}
yini  <- c(1, 0) # initial conditions
dyini <- c(1, 0)
times <- seq(0, 20, 0.1)
out <- daspk(y = yini, dy = dyini, times = times, res = daefun, parms = 0)
out <- daspk(y = yini, dy = dyini, times = times, res = f, parms = 0)
matplot(out[,1], out[,2:3], type = "l", lwd = 2, main = "dae", xlab = "time", ylab = "y")
head(out)
matplot(out[,1], out[,2:3], type = "l", lwd = 2, main = "DAE", xlab = "time", ylab = "ys", col=c("red","gold"))
matplot(out[,1], out[,2:3], type = "l", lwd = 2, col=c("red","blue"), lty=1,
main = "DAE", xlab = "time", ylab = "ys")
legend("bottomright",legend=c("y1","y2"), col=c("red","blue"), lty=1)
legend("bottomright",legend=c("y1","y2"), col=c("red","blue"), lty=1, lwd="")
legend("bottomright",legend=c("y1","y2"), col=c("red","blue"), lty=1, lwd=2)
dyini <- c(1, -1)
out <- daspk(y = yini, dy = dyini, times = times, res = f, parms = 0)
matplot(out[,1], out[,2:3], type = "l", lwd = 2, col=c("red","blue"), lty=1,
main = "DAE", xlab = "time", ylab = "ys")
matplot(out[,1], out[,2:3], type = "l", lwd = 2, col=c("red","blue"), lty=1,
main = "DAE", xlab = "time", ylab = "ys")
dyini <- c(2, -1)
times <- seq(0, 20, 0.1)
out <- daspk(y = yini, dy = dyini, times = times, res = f, parms = 0)
matplot(out[,1], out[,2:3], type = "l", lwd = 2, col=c("red","blue"), lty=1,
main = "DAE", xlab = "time", ylab = "ys")
yini  <- c(2, 4) # initial conditions
dyini <- c(2, -1)
times <- seq(0, 20, 0.1)
out <- daspk(y = yini, dy = dyini, times = times, res = f, parms = 0)
matplot(out[,1], out[,2:3], type = "l", lwd = 2, col=c("red","blue"), lty=1,
main = "DAE", xlab = "time", ylab = "ys")
legend("bottomright",legend=c("y1","y2"), col=c("red","blue"), lty=1, lwd=2)
yini  <- c(2, 4) # initial conditions
dyini <- c(2, 0)
times <- seq(0, 20, 0.1)
out <- daspk(y = yini, dy = dyini, times = times, res = f, parms = 0)
matplot(out[,1], out[,2:3], type = "l", lwd = 2, col=c("red","blue"), lty=1,
main = "DAE", xlab = "time", ylab = "ys")
legend("bottomright",legend=c("y1","y2"), col=c("red","blue"), lty=1, lwd=2)
yini  <- c(2, 1) # initial conditions
out <- daspk(y = yini, dy = dyini, times = times, res = f, parms = 0)
matplot(out[,1], out[,2:3], type = "l", lwd = 2, col=c("red","blue"), lty=1,
main = "DAE", xlab = "time", ylab = "ys")
yini  <- c(2, 0) # initial conditions
dyini <- c(1, 0)
times <- seq(0, 20, 0.1)
out <- daspk(y = yini, dy = dyini, times = times, res = f, parms = 0)
matplot(out[,1], out[,2:3], type = "l", lwd = 2, col=c("red","blue"), lty=1,
main = "DAE", xlab = "time", ylab = "ys")
legend("bottomright",legend=c("y1","y2"), col=c("red","blue"), lty=1, lwd=2)
dyini <- c(3, 0)
out <- daspk(y = yini, dy = dyini, times = times, res = f, parms = 0)
matplot(out[,1], out[,2:3], type = "l", lwd = 2, col=c("red","blue"), lty=1,
main = "DAE", xlab = "time", ylab = "ys")
legend("bottomright",legend=c("y1","y2"), col=c("red","blue"), lty=1, lwd=2)
dyini <- c(1, 0)
times <- seq(0, 20, 0.1)
out <- daspk(y = yini, dy = dyini, times = times, res = f, parms = 0)
matplot(out[,1], out[,2:3], type = "l", lwd = 2, col=c("red","blue"), lty=1,
main = "DAE", xlab = "time", ylab = "ys")
legend("bottomright",legend=c("y1","y2"), col=c("red","blue"), lty=1, lwd=2)
parameters = list(D=0.3,       # diffusion rate; m^2/day
r=0.01,      # net growth rate; day^-1
numboxes=60, # number of boxes
delx=delx)   # thickness of each box; m
Aphid <- function(t, N, parameters) {
with(parameters,{
deltax  <- c(0.5, rep(1, numboxes - 1), 0.5)
Flux    <- -D * diff(c(0, N, 0)) / deltax
dN      <- -diff(Flux) / delx + N * r
list(dN)
})
}
# initial condition
N <- rep(0, times = numboxes)
N[30:31] <- 1
state <- c(N = N) # initialise state variables
# let's run for 300 days
times <- seq(0, 300, by = 1)
out <- ode.1D(state, times, Aphid, parms = parameters, nspec = 1, names = "Aphid")
head(out[,1:5])
head(out[,1:5])
summary(out)
image(out, method = "filled.contour",
grid = seq(from = 0.5, by = delx, length.out = numboxes),
xlab = "time, days", ylab = "Distance on plant, meters",
main = "Aphid density on a row of plants")
parameters$numboxes
parameters = list(D=0.3,       # diffusion rate; m^2/day
r=0.01,      # net growth rate; day^-1
numboxes=60, # number of boxes
delx=1)      # thickness of each box; m
Aphid <- function(t, N, parameters) {
with(parameters,{
deltax  <- c(0.5, rep(1, numboxes - 1), 0.5)
Flux    <- -D * diff(c(0, N, 0)) / deltax
dN      <- -diff(Flux) / delx + N * r
list(dN)
})
}
# initial condition
N <- rep(0, times = numboxes)
N[30:31] <- 1
state <- c(N = N) # initialise state variables
# let's run for 300 days
times <- seq(0, 300, by = 1)
out <- ode.1D(state, times, Aphid, parms = parameters, nspec = 1, names = "Aphid")
N <- rep(0, times =  parameters$numboxes)
N[30:31] <- 1
state <- c(N = N) # initialise state variables
# let's run for 300 days
times <- seq(0, 300, by = 1)
out <- ode.1D(state, times, Aphid, parms = parameters, nspec = 1, names = "Aphid")
parameters = list(D=0.3,       # diffusion rate; m^2/day
r=0.01,      # net growth rate; day^-1
numboxes=60, # number of boxes
delx=1)      # thickness of each box; m
Aphid <- function(t, N, parameters) {
with(parameters,{
deltax  <- c(0.5, rep(1, numboxes - 1), 0.5)
Flux    <- -D * diff(c(0, N, 0)) / deltax
dN      <- -diff(Flux) / delx + N * r
list(dN)
})
}
# initial condition
N <- rep(0, times =  parameters$numboxes)
N[30:31] <- 1
state <- c(N = N) # initialise state variables
# let's run for 300 days
times <- seq(0, 300, by = 1)
out <- ode.1D(state, times, Aphid, parms = parameters, nspec = 1, names = "Aphid")
head(out[,1:5])
summary(out)
image(out, method = "filled.contour",
grid = seq(from = 0.5, by = delx, length.out = parameters$numboxes),
xlab = "time, days", ylab = "Distance on plant, meters",
main = "Aphid density on a row of plants")
library(BRugs)
#------------------------------------------------------------------------------
run.model <- function(model, samples, data=list(), chainLength=10000, burnin=0.10,
init.func, n.chains=1, thin=1) {
writeLines(model, con="model.txt")  # Write the modelString to a file
modelCheck( "model.txt" )           # Send the model to BUGS, which checks the model syntax
if (length(data)>0)                 # If there's any data available...
modelData(bugsData(data))         # ... BRugs puts it into a file and ships it to BUGS
modelCompile()                      # BRugs command tells BUGS to compile the model
if (missing(init.func)) {
modelGenInits()                   # BRugs command tells BUGS to randomly initialize a chain
} else {
for (chain in 1:n.chains) {       # otherwise use user's init data
modelInits(bugsInits(init.func))
}
}
modelUpdate(chainLength*burnin)     # Burn-in period to be discarded
samplesSet(samples)                 # BRugs tells BUGS to keep a record of the sampled values
samplesSetThin(thin)                # Set thinning
modelUpdate(chainLength)            # BRugs command tells BUGS to randomly initialize a chain
}
#------------------------------------------------------------------------------
samples <- read.csv("mixture_data.csv", header=F)[,1]
samples <- as.numeric(levels(samples)[samples])  # because it read the values as factors
hist(samples, breaks=40)
setwd("~/Documents/Dropbox/My Work/Projects/R/Markdowns/bugs")
samples <- read.csv("mixture_data.csv", header=F)[,1]
samples <- as.numeric(levels(samples)[samples])  # because it read the values as factors
hist(samples, breaks=40)
modelString = "
# BUGS model specification begins ...
model {
for( i in 1 : N ) {
y[i]   ~  dnorm(mu[i], tau[i])  # likelihood
mu[i]  <- lambda[G[i]]          # prior for mean
tau[i] <- lambdaTau[G[i]]       # prior for precision
G[i]   ~  dcat(P[])             # the cluster attributions for each y_i
}
P[1:2] ~ ddirch(alpha[])           # dirichlet distribution (in this case just for 2 clusters)
alpha[1] <- 0.5                    # It generalizes the beta (with K=2 we could have used the beta), and
alpha[2] <- 0.5                    # is the conjugate for the categorical distribution
lambda[1] ~ dnorm(0.0, 1.0E-6)     # hyperparameters for mean
lambda[2] <- lambda[1] + theta
theta ~ dnorm(0.0, 1.0E-6)I(0.0, )
lambdaTau[1] ~ dgamma(0.01,0.01)   # hyperparameters for precision/standard deviation
lambdaTau[2] ~ dgamma(0.01,0.01)
sigma[1] <- 1 / sqrt(lambdaTau[1])
sigma[2] <- 1 / sqrt(lambdaTau[2])
}
# ... BUGS model specification ends.
" # close quote to end modelString
data.list = list(
y = samples,
N = length(samples),
G = c(1, rep(NA,length(samples)-2), 2)
)
# let's apply some thinning here:
run.model(modelString, samples=c("sigma", "lambda", "P", "G"), data=data.list, chainLength=3e4, thin=4)
samplesStats("sigma")
samplesStats("lambda")
samplesStats("P")
samplesStats("G[1]")
samplesStats("G")
samplesSample("P[1]")[1:20]
samplesSample("P[2]")[1:20]
samples[1:20]
samples[20:40]
samplesSample("P[1]")[20:40]  # the assignments for each datapoint
samplesSample("P[2]")[20:40]
plot(samples, samplesSample("P[1]"), xlim=(0,300))
plot(samples, samplesSample("P[1]"), xlim=c(0,300))
samples
samplesSample("P[1]")
samplesStats("G")
df <- samplesStats("G")
df
df[,1]
df[,1] -1
round(df[,1] - 1)
plot(samples, df[,1], xlim=c(0,300))
plot(samples, c(1,df[,1],2), xlim=c(0,300))
plot(samples, c(1,df[,1],2), col = round(df[,1] - 1), xlim=c(0,300))
plot(samples, c(1,df[,1],2), col = round(df[,1]), xlim=c(0,300))
plot(samples, c(1,df[,1],2)-1, col = round(df[,1]), xlim=c(0,300), xlab="data point", ylab="probability")
data
samples
which.max(samples)
plot(samples, c(1,df[,1],2)-1, col = c(1,round(df[,1]),2), xlim=c(0,300), xlab="data point", ylab="probability")
samplesStats("G")[,1]
prob.cluster.1 <- samplesStats("G")[,1] - 1
plot(samples, 1-c(0,df[,1],1), col = c(1,round(df[,1]),2), xlim=c(0,300),
xlab="data point", ylab="probability", main="probability of belonging to first cluster")
prob.cluster.1
1-c(0,df[,1],1)
plot(samples, 1-c(0,prob.cluster.1[,1],1), col = c(1,round(prob.cluster.1[,1]),2), xlim=c(0,300),
xlab="data point", ylab="probability", main="probability of belonging to first cluster")
plot(samples, 1-c(0,prob.cluster.1,1), col = c(1,round(prob.cluster.1),2), xlim=c(0,300),
xlab="data point", ylab="probability", main="probability of belonging to first cluster")
plot(samples, 1-c(0,prob.cluster.1,1), col = 1+c(1,round(prob.cluster.1),2), xlim=c(0,300),
xlab="data point", ylab="probability", main="probability of belonging to first cluster")
round(prob.cluster.1)
plot(samples, 1-c(0,prob.cluster.1,1), col = 1+c(0,round(prob.cluster.1),1), xlim=c(0,300),
xlab="data point", ylab="probability", main="probability of belonging to first cluster")
samplesHistory(c("lambda[1]","lambda[2]"), mfrow = c(4, 2))
samplesHistory("lambda[1]", mfrow = c(4, 2))
samplesDensity("lambda[1]", mfrow = c(1, 1))
samplesAutoC("lambda[1]", mfrow = c(1, 1), 1)
prob.cluster.1 <- samplesStats("G")[,1] - 1
plot(samples, 1-c(0,prob.cluster.1,1), col = 1+c(0,round(prob.cluster.1),1), xlim=c(0,300),
xlab="data point", ylab="probability", main="probability of belonging to first cluster", pch=19)
samples[c(-1,-300)]
plot(samples[c(-1,-300)], 1-prob.cluster.1), col = 1+round(prob.cluster.1), xlim=c(0,300),
xlab="data point", ylab="probability", main="probability of belonging to first cluster", pch=19)
plot(samples[c(-1,-300)], 1-prob.cluster.1, col = 1+round(prob.cluster.1), xlim=c(0,300),
xlab="data point", ylab="probability", main="probability of belonging to first cluster", pch=19)
samplesStats("G")[,1]
prob.cluster.1
prob.cluster.1 <- 2 - samplesStats("G")[,1]
plot(samples[c(-1,-300)], prob.cluster.1, col = 1+round(prob.cluster.1), xlim=c(0,300),
xlab="data point", ylab="probability", main="probability of belonging to first cluster", pch=19)
plot(samples[c(-1,-300)], prob.cluster.1, col = 1+round(prob.cluster.1), xlim=c(0,300),
xlab="data point", ylab="probability", main="probability of belonging to first cluster", pch=19)
plot(samples[c(-1,-300)], prob.cluster.1, col = c("red","blue")[1+round(prob.cluster.1)], xlim=c(0,300),
xlab="data point", ylab="probability", main="probability of belonging to first cluster", pch=19)
round(prob.cluster.1)
plot(samples[c(-1,-300)], prob.cluster.1, col = c("blue","red")[1+round(prob.cluster.1)], xlim=c(0,300),
xlab="data point", ylab="probability", main="probability of belonging to first cluster", pch=19)
