p2 ~ uniform(0,1);
increment_log_prob(lincoln_log(D,n,p1,p2));
}
'
fit <- stan(model_code = model, data = list(k1=20, k2=15, c=3), iter = 1000, chains = 4)
model <- '
functions {
real lincoln_log(vector D, real n, real p1, real p2) {
int k1; int k2; int c;
real choose1; real binom1; real binom2; real choose2; real choose3;
k1 <- D[1];
k2 <- D[2];
c  <- D[3];
choose1 <- exp( lgamma(n+1) - (lgamma(k1+1) + lgamma(n-k1+1)) );
binom1  <- pow(p1, k1) * pow(1-p1, n-k1);
choose2 <- exp( lgamma(k1+1) - (lgamma(c+1) + lgamma(k1-c+1)) );
choose3 <- exp( lgamma(n-k1+1) - (lgamma(k2-c+1) + lgamma(n-k1-k2+c+1)) );
binom2  <- pow(p2, k2) * pow(1-p2, n-k2);
return choose1 * binom1 * choose2 * choose3 * binom2;
}
real
}
data {
int<lower=0>  k1;
int<lower=0>  k2;
int<lower=0>  c;
}
transformed data {
int<lower=0>  m1;
int<lower=0>  m2;
vector[3] D;
m1 <- k1+k2-c;
m2 <- 350;
D[1] <- k1;
D[2] <- k2;
D[3] <- c;
}
parameters {
real<lower=m1, upper=m2>  n;
real<lower=0, upper=1>   p1;
real<lower=0, upper=1>   p2;
}
model {
n  ~ uniform(m1,m2);
p1 ~ uniform(0,1);
p2 ~ uniform(0,1);
increment_log_prob(lincoln_log(D,n,p1,p2));
}
'
fit <- stan(model_code = model, data = list(k1=20, k2=15, c=3), iter = 1000, chains = 4)
model <- '
functions {
real lincoln_log(vector D, real n, real p1, real p2) {
real k1; real k2; real c;
real choose1; real binom1; real binom2; real choose2; real choose3;
k1 <- D[1];
k2 <- D[2];
c  <- D[3];
choose1 <- exp( lgamma(n+1) - (lgamma(k1+1) + lgamma(n-k1+1)) );
binom1  <- pow(p1, k1) * pow(1-p1, n-k1);
choose2 <- exp( lgamma(k1+1) - (lgamma(c+1) + lgamma(k1-c+1)) );
choose3 <- exp( lgamma(n-k1+1) - (lgamma(k2-c+1) + lgamma(n-k1-k2+c+1)) );
binom2  <- pow(p2, k2) * pow(1-p2, n-k2);
return choose1 * binom1 * choose2 * choose3 * binom2;
}
real
}
data {
int<lower=0>  k1;
int<lower=0>  k2;
int<lower=0>  c;
}
transformed data {
int<lower=0>  m1;
int<lower=0>  m2;
vector[3] D;
m1 <- k1+k2-c;
m2 <- 350;
D[1] <- k1;
D[2] <- k2;
D[3] <- c;
}
parameters {
real<lower=m1, upper=m2>  n;
real<lower=0, upper=1>   p1;
real<lower=0, upper=1>   p2;
}
model {
n  ~ uniform(m1,m2);
p1 ~ uniform(0,1);
p2 ~ uniform(0,1);
increment_log_prob(lincoln_log(D,n,p1,p2));
}
'
fit <- stan(model_code = model, data = list(k1=20, k2=15, c=3), iter = 1000, chains = 4)
model <- '
functions {
real lincoln_log(vector D, real n, real p1, real p2) {
real k1; real k2; real c;
real choose1; real binom1; real binom2; real choose2; real choose3;
k1 <- D[1];
k2 <- D[2];
c  <- D[3];
choose1 <- exp( lgamma(n+1) - (lgamma(k1+1) + lgamma(n-k1+1)) );
binom1  <- pow(p1, k1) * pow(1-p1, n-k1);
choose2 <- exp( lgamma(k1+1) - (lgamma(c+1) + lgamma(k1-c+1)) );
choose3 <- exp( lgamma(n-k1+1) - (lgamma(k2-c+1) + lgamma(n-k1-k2+c+1)) );
binom2  <- pow(p2, k2) * pow(1-p2, n-k2);
return choose1 * binom1 * choose2 * choose3 * binom2;
}
}
data {
int<lower=0>  k1;
int<lower=0>  k2;
int<lower=0>  c;
}
transformed data {
int<lower=0>  m1;
int<lower=0>  m2;
vector[3] D;
m1 <- k1+k2-c;
m2 <- 350;
D[1] <- k1;
D[2] <- k2;
D[3] <- c;
}
parameters {
real<lower=m1, upper=m2>  n;
real<lower=0, upper=1>   p1;
real<lower=0, upper=1>   p2;
}
model {
n  ~ uniform(m1,m2);
p1 ~ uniform(0,1);
p2 ~ uniform(0,1);
increment_log_prob(lincoln_log(D,n,p1,p2));
}
'
fit <- stan(model_code = model, data = list(k1=20, k2=15, c=3), iter = 1000, chains = 4)
fit2 <- stan(fit = fit, data = data, iter = 10000, chains = 4)
print(fit2)
model <- '
functions {
real lincoln_log(vector D, real n, real p1, real p2) {
real k1; real k2; real c;
real choose1; real binom1; real binom2; real choose2; real choose3;
k1 <- D[1];
k2 <- D[2];
c  <- D[3];
choose1 <- exp( lgamma(n+1) - (lgamma(k1+1) + lgamma(n-k1+1)) );
binom1  <- pow(p1, k1) * pow(1-p1, n-k1);
choose2 <- exp( lgamma(k1+1) - (lgamma(c+1) + lgamma(k1-c+1)) );
choose3 <- exp( lgamma(n-k1+1) - (lgamma(k2-c+1) + lgamma(n-k1-k2+c+1)) );
binom2  <- pow(p2, k2) * pow(1-p2, n-k2);
return choose1 * binom1 * choose2 * choose3 * binom2;
}
}
data {
int<lower=0>  k1;
int<lower=0>  k2;
int<lower=0>  c;
}
transformed data {
int<lower=0>  m1;
int<lower=0>  m2;
vector[3] D;
m1 <- k1+k2-c;
m2 <- 350;
D[1] <- k1;
D[2] <- k2;
D[3] <- c;
}
parameters {
real n;
real p1;
real p2;
}
model {
n  ~ uniform(m1,m2);
p1 ~ uniform(0,1);
p2 ~ uniform(0,1);
increment_log_prob(lincoln_log(D,n,p1,p2));
}
'
fit <- stan(model_code = model, data = list(k1=20, k2=15, c=3), iter = 1000, chains = 4)
fit2 <- stan(fit = fit, data = data, iter = 10000, chains = 4)
print(fit2)
model <- '
functions {
real lincoln_log(vector D, real n, real p1, real p2) {
real k1; real k2; real c; k1 <- D[1]; k2 <- D[2]; c  <- D[3];
real choose1; real binom1; real binom2; real choose2; real choose3;
choose1 <- exp( lgamma(n+1) - (lgamma(k1+1) + lgamma(n-k1+1)) );
binom1  <- pow(p1, k1) * pow(1-p1, n-k1);
choose2 <- exp( lgamma(k1+1) - (lgamma(c+1) + lgamma(k1-c+1)) );
choose3 <- exp( lgamma(n-k1+1) - (lgamma(k2-c+1) + lgamma(n-k1-k2+c+1)) );
binom2  <- pow(p2, k2) * pow(1-p2, n-k2);
return choose1 * binom1 * choose2 * choose3 * binom2;
}
}
data {
int<lower=0>  k1;
int<lower=0>  k2;
int<lower=0>  c;
}
transformed data {
int<lower=0>  m1;
int<lower=0>  m2;
vector[3] D;
m1 <- k1+k2-c;
m2 <- 350;
D[1] <- k1;
D[2] <- k2;
D[3] <- c;
}
parameters {
real<lower=m1, upper=m2> n;
real<lower=0, upper=1>  p1;
real<lower=0, upper=1>  p2;
}
model {
n  ~ uniform(m1,m2);
p1 ~ uniform(0,1);
p2 ~ uniform(0,1);
increment_log_prob(lincoln_log(D,n,p1,p2));
}
'
fit <- stan(model_code = model, data = list(k1=20, k2=15, c=3), iter = 1000, chains = 4)
model <- '
functions {
real lincoln_log(vector D, real n, real p1, real p2) {
real k1; real k2; real c;
real choose1; real binom1; real binom2; real choose2; real choose3;
k1 <- D[1]; k2 <- D[2]; c  <- D[3];
choose1 <- exp( lgamma(n+1) - (lgamma(k1+1) + lgamma(n-k1+1)) );
binom1  <- pow(p1, k1) * pow(1-p1, n-k1);
choose2 <- exp( lgamma(k1+1) - (lgamma(c+1) + lgamma(k1-c+1)) );
choose3 <- exp( lgamma(n-k1+1) - (lgamma(k2-c+1) + lgamma(n-k1-k2+c+1)) );
binom2  <- pow(p2, k2) * pow(1-p2, n-k2);
return choose1 * binom1 * choose2 * choose3 * binom2;
}
}
data {
int<lower=0>  k1;
int<lower=0>  k2;
int<lower=0>  c;
}
transformed data {
int<lower=0>  m1;
int<lower=0>  m2;
vector[3] D;
m1 <- k1+k2-c;
m2 <- 350;
D[1] <- k1;
D[2] <- k2;
D[3] <- c;
}
parameters {
real<lower=m1, upper=m2> n;
real<lower=0, upper=1>  p1;
real<lower=0, upper=1>  p2;
}
model {
n  ~ uniform(m1,m2);
p1 ~ uniform(0,1);
p2 ~ uniform(0,1);
increment_log_prob(lincoln_log(D,n,p1,p2));
}
'
fit <- stan(model_code = model, data = list(k1=20, k2=15, c=3), iter = 1000, chains = 4)
fit2 <- stan(fit = fit, data = data, iter = 10000, chains = 4)
print(fit2)
fit2 <- stan(fit = fit, data = data, iter = 50000, chains = 4)
print(fit2)
model <- '
functions {
real lincoln_log(vector D, real n, real p1, real p2) {
real k1; real k2; real c;
real choose1; real binom1; real binom2; real choose2; real choose3;
k1 <- D[1]; k2 <- D[2]; c <- D[3];
choose1 <- exp( lgamma(n+1)    - (lgamma(k1+1)   + lgamma(n-k1+1)) );
binom1  <- pow(p1, k1) * pow(1-p1, n-k1);
choose2 <- exp( lgamma(k1+1)   - (lgamma(c+1)    + lgamma(k1-c+1)) );
choose3 <- exp( lgamma(n-k1+1) - (lgamma(k2-c+1) + lgamma(n-k1-k2+c+1)) );
binom2  <- pow(p2, k2) * pow(1-p2, n-k2);
return choose1 * binom1 * choose2 * choose3 * binom2;
}
}
data {
int<lower=0>  k1;
int<lower=0>  k2;
int<lower=0>  c;
}
transformed data {
int<lower=0>  m1;
int<lower=0>  m2;
vector[3] D;
m1 <- k1+k2-c;
m2 <- 350;
D[1] <- k1;
D[2] <- k2;
D[3] <- c;
}
parameters {
real<lower=m1, upper=m2> n;
real<lower=0, upper=1>  p1;
real<lower=0, upper=1>  p2;
}
model {
n  ~ uniform(m1,m2);   // priors
p1 ~ uniform(0,1);
p2 ~ uniform(0,1);
// increment_log_prob(lincoln_log(D,n,p1,p2));  // likelihood
D ~ lincoln(n,p1,p2);
}
'
fit <- stan(model_code = model, data = list(k1=20, k2=15, c=3), iter = 1000, chains = 4)
fit2 <- stan(fit = fit, data = data, iter = 50000, chains = 4)
print(fit2)
model <- '
functions {
real lincoln_log(vector D, real n, real p1, real p2) {
real k1; real k2; real c;
real choose1; real binom1; real binom2; real choose2; real choose3;
k1 <- D[1]; k2 <- D[2]; c <- D[3];
choose1 <- exp( lgamma(n+1)    - (lgamma(k1+1)   + lgamma(n-k1+1)) );
binom1  <- pow(p1, k1) * pow(1-p1, n-k1);
choose2 <- exp( lgamma(k1+1)   - (lgamma(c+1)    + lgamma(k1-c+1)) );
choose3 <- exp( lgamma(n-k1+1) - (lgamma(k2-c+1) + lgamma(n-k1-k2+c+1)) );
binom2  <- pow(p2, k2) * pow(1-p2, n-k2);
return log() choose1 * binom1 * choose2 * choose3 * binom2 );
}
}
data {
int<lower=0>  k1;
int<lower=0>  k2;
int<lower=0>  c;
}
transformed data {
int<lower=0>  m1;
int<lower=0>  m2;
vector[3] D;
m1 <- k1+k2-c;
m2 <- 350;
D[1] <- k1;
D[2] <- k2;
D[3] <- c;
}
parameters {
real<lower=m1, upper=m2> n;
real<lower=0, upper=1>  p1;
real<lower=0, upper=1>  p2;
}
model {
n  ~ uniform(m1,m2);   // priors
p1 ~ uniform(0,1);
p2 ~ uniform(0,1);
D ~ lincoln(n,p1,p2);   // likelihood, also: increment_log_prob(lincoln_log(D,n,p1,p2));
}
'
fit <- stan(model_code = model, data = list(k1=20, k2=15, c=3), iter = 1000, chains = 4)
model <- '
functions {
real lincoln_log(vector D, real n, real p1, real p2) {
real k1; real k2; real c;
real choose1; real binom1; real binom2; real choose2; real choose3;
k1 <- D[1]; k2 <- D[2]; c <- D[3];
choose1 <- exp( lgamma(n+1)    - (lgamma(k1+1)   + lgamma(n-k1+1)) );
binom1  <- pow(p1, k1) * pow(1-p1, n-k1);
choose2 <- exp( lgamma(k1+1)   - (lgamma(c+1)    + lgamma(k1-c+1)) );
choose3 <- exp( lgamma(n-k1+1) - (lgamma(k2-c+1) + lgamma(n-k1-k2+c+1)) );
binom2  <- pow(p2, k2) * pow(1-p2, n-k2);
return log( choose1 * binom1 * choose2 * choose3 * binom2 );
}
}
data {
int<lower=0>  k1;
int<lower=0>  k2;
int<lower=0>  c;
}
transformed data {
int<lower=0>  m1;
int<lower=0>  m2;
vector[3] D;
m1 <- k1+k2-c;
m2 <- 350;
D[1] <- k1;
D[2] <- k2;
D[3] <- c;
}
parameters {
real<lower=m1, upper=m2> n;
real<lower=0, upper=1>  p1;
real<lower=0, upper=1>  p2;
}
model {
n  ~ uniform(m1,m2);   // priors
p1 ~ uniform(0,1);
p2 ~ uniform(0,1);
D ~ lincoln(n,p1,p2);   // likelihood, also: increment_log_prob(lincoln_log(D,n,p1,p2));
}
'
fit <- stan(model_code = model, data = list(k1=20, k2=15, c=3), iter = 1000, chains = 4)
fit2 <- stan(fit = fit, data = data, iter = 50000, chains = 4)
print(fit2)
la <- extract(fit2, permuted = TRUE)
names(la)
hist(la$n)
hist(la$n, breaks=100)
dst <- density(la$n)
stan.n.bugs <- dst$x[which.max(dst$y)]    # get the MAP from the estimated density
stan.n.bugs
lines(dst, col="red", lwd=2)
hist(la$n, breaks=100, prob=TRUE, xlab="Number of bugs", main="Posterior p(n|D)")
dst <- density(la$n)
lines(dst, col="red", lwd=2)
stan.n.bugs <- dst$x[which.max(dst$y)]    # get the MAP from the estimated density
stan.n.bugs
fit2 <- stan(fit = fit, data = data, iter = 100000, chains = 4)
print(fit2)
la <- extract(fit2, permuted = TRUE)
hist(la$n, breaks=100, prob=TRUE, xlab="Number of bugs", main="Posterior p(n|D)")
dst <- density(la$n)
lines(dst, col="red", lwd=2)
stan.n.bugs <- dst$x[which.max(dst$y)]    # get the MAP from the estimated density
stan.n.bugs
setwd("~/Documents/Dropbox/My Work/Projects/R/My_Markdowns/bugs")
library(rstan)
model <- '
functions {
real lincoln_log(vector D, real n, real p1, real p2) {
real k1; real k2; real c;
real choose1; real binom1; real binom2; real choose2; real choose3;
k1 <- D[1]; k2 <- D[2]; c <- D[3];
choose1 <- exp( lgamma(n+1)    - (lgamma(k1+1)   + lgamma(n-k1+1)) );
binom1  <- pow(p1, k1) * pow(1-p1, n-k1);
choose2 <- exp( lgamma(k1+1)   - (lgamma(c+1)    + lgamma(k1-c+1)) );
choose3 <- exp( lgamma(n-k1+1) - (lgamma(k2-c+1) + lgamma(n-k1-k2+c+1)) );
binom2  <- pow(p2, k2) * pow(1-p2, n-k2);
return log( choose1 * binom1 * choose2 * choose3 * binom2 );
}
}
data {
int<lower=0>  k1;   // bugs found by tester 1
int<lower=0>  k2;   // bugs found by tester 2
int<lower=0>  c;    // number of common bugs
}
transformed data {
int<lower=0>  m1;   // lower bound for n
int<lower=0>  m2;   // upper bound for n
vector[3] D;
m1 <- k1+k2-c;
m2 <- 350;
D[1] <- k1; D[2] <- k2; D[3] <- c;
}
parameters {
real<lower=m1, upper=m2> n;   // the number of total bugs
real<lower=0, upper=1>  p1;   // performance of tester 1
real<lower=0, upper=1>  p2;   // performance of tester 2
}
model {
n  ~ uniform(m1,m2);   // priors
p1 ~ uniform(0,1);
p2 ~ uniform(0,1);
D ~ lincoln(n,p1,p2);  // likelihood, equivalent to: increment_log_prob(lincoln_log(D,n,p1,p2));
}
'
fit <- stan(model_code = model, data = list(k1=20, k2=15, c=3), iter = 1000, chains = 4)
fit2 <- stan(fit = fit, data = data, iter = 100000, chains = 4)
print(fit2)
la <- extract(fit2, permuted = TRUE)
hist(la$n, breaks=100, prob=TRUE, xlab="Number of bugs", main="Posterior p(n|D)")
dst <- density(la$n)
lines(dst, col="red", lwd=2)
stan.n.bugs <- dst$x[which.max(dst$y)]    # get the MAP from the estimated density
stan.n.bugs
dst$x
la$n
class(la$n)
as.vector(la$n)
hist(as.vector(la$n), breaks=100, prob=TRUE, xlab="Number of bugs", main="Posterior p(n|D)")
dst <- density(la$n)
lines(dst, col="red", lwd=2)
stan.n.bugs <- dst$x[which.max(dst$y)]    # get the MAP from the estimated density
stan.n.bugs
fit2 <- stan(fit = fit, data = data, iter = 100000, chains = 4)
print(fit2)
la <- extract(fit2, permuted = TRUE)
hist(as.vector(la$n), breaks=100, prob=TRUE, xlab="Number of bugs", main="Posterior p(n|D)")
dst <- density(la$n)
lines(dst, col="red", lwd=2)
stan.n.bugs <- dst$x[which.max(dst$y)]    # get the MAP from the estimated density
stan.n.bugs
fit <- stan(model_code = model, data = list(k1=20, k2=15, c=3), iter = 1000, chains = 4)
fit2 <- stan(fit = fit, data = data, iter = 100000, chains = 4)
print(fit2)
la <- extract(fit2, permuted = TRUE)
hist(as.vector(la$n), breaks=100, prob=TRUE, xlab="Number of bugs", main="Posterior p(n|D)")
dst <- density(la$n)
lines(dst, col="red", lwd=2)
stan.n.bugs <- dst$x[which.max(dst$y)]    # get the MAP from the estimated density
stan.n.bugs
fit <- stan(model_code = model, data = list(k1=20, k2=15, c=3), iter = 1000, chains = 4, verbose = FALSE)
fit2 <- stan(fit = fit,          data = list(k1=20, k2=15, c=3), iter = 100000, chains = 4, verbose = FALSE)
fit2 <- stan(fit = fit,          data = list(k1=20, k2=15, c=3), iter = 100000, chains = 4, verbose = FALSE, seed=101)
fit2 <- stan(fit = fit,          data = list(k1=20, k2=15, c=3), iter = 50000, chains = 4, verbose = FALSE, seed=101, warmup=iter/10)
fit2 <- stan(fit = fit,          data = list(k1=20, k2=15, c=3), iter = 50000, chains = 4, verbose = FALSE, seed=101, warmup=5000)
la <- extract(fit2, permuted = TRUE)
dst <- density(la$n)
lines(dst, col="red", lwd=2)
stan.n.bugs <- dst$x[which.max(dst$y)]    # get the MAP from the estimated density
stan.n.bugs
